## c++的三种内存管理机制 --- 栈、堆、RAII


## 栈 和 堆 
程序内存结构里还包括代码段、静态变量区等区域。

###栈和堆的区别：

1. 内存中的栈和栈的数据结构十分类似，都采用先进后出的数据结构，是连续的。
 堆是操作系统分配的不连续的内存。
2. 栈在内存中的增长方向是从高地址往低地址分配的。并且栈的空间是有限的，滥用占资源会导致栈溢出的问题（如递归数量过大，分配元素过多）
 堆在内存中的增长方向是从低地址到高地址的。理论上堆的内存是无限大的，实际情况需要考虑物理内存的大小。
3. 程序运行的函数是按先进先出顺序分配在栈空间的，而函数里直接定义的变量也是分配在栈空间的。这些变量在函数运行结束后会主动退出栈空间，函数在运行结束也会执行出栈操作。
 而程序在使用new、malloc、alloc等分配内存的操作时，会返回一块堆空间的地址，而在外面用一个栈空间的指针去指向这块地址。堆空间的内存需要手动释放，但是在程序结束时，系统回收程序资源时也会帮你释放。
 4. 栈空间在分配内存的时候，仅仅需要移动栈指针，所以不会产生内存碎片的问题。在栈上分配内存是很快的。而且由于栈不会对入栈的地址进行初始化操作，所以可以认为入栈的地址是脏的，我们单单声明一个变量但是不初始化，他里面的值是未知的。
 对于堆来说，他分配内存是在操作系统给的虚拟内存中查找的，每次都要从中间找一块合适的内存，这些内存是散布的，所以会产生内存碎片的问题。（主要是外部碎片）
5. 栈分配内存只要通过栈指针判断一下大小，不够就栈溢出异常。所以栈分配内存是很快的。
   对于堆来说，他需要在一个记录内存的链表中查询满足要求的内存块，将他从链表中取出使用，在释放内存后也需要把他重新插回链表里，所以堆内存分配是比栈慢的。

###堆的使用场景（准确说是不应该存在栈上的情况）：
1. 要求分配的内存很大。（可能超过了栈的大小）
2. 要求分配的大小在编译阶段不确定。 （如：int a[n])
3. 从函数返回地址时要用堆。（函数中的元素在函数返回时会被销毁，不能返回栈元素的地址）

###堆在使用过程中需要注意的问题
```cpp
void fun() {
	T* a = new T;
	....
	delete a;
}
```
这段代码看似没什么毛病，但是如果在...里面存在异常报错的话，后面的delete便无法执行。而且这里一般不会使用堆内存，堆内存多用在不同的函数里。但这样就会存在忘记释放内存的情况。

###解决方案 RAII
RAII在代码中需要靠构造、析构函数实现。
析构函数在变量退出作用域的时候会主动调用（这个操作也叫栈展开），这样我们就不必记得什么时候需要去释放这块堆内存。
同时，对于发生异常的情况，变量还是会调用析构函数释放内存，而不是直接跳过delete。

###RAII机制常见的应用
智能指针 （c++2.0开始推荐使用智能指针代替普通的指针）
计时器（我们可以在函数的开始定义一个计时器的类，类的构造函数开始计时，在退出函数的时候调用析构函数，打印计时结果）



接下来简单的实现智能指针完成RAII功能