#每日bug分享（多文件编程）：

这是我在写unique_ptr时遇到的一个bug。深挖下去篇幅逐渐加长就单独整理出来了，意义深远。

本来已经在一个cpp源文件实现了基本功能，并且可以跑了，闲来无事，我就打算写一个头文件来保存类的声明，然后这个cpp文件来写函数的实现。报错了。通过写了类似的，先加上了命名空间，然后加上模板的时候报错。为什么呢？前前后后翻书上网查了很多资料，得到下面的解释。


每次使用到多文件编译，我就会懵逼，写写小东西还行（但是又没必要），涉及到大一点的程序就不行了，不知道头文件里应该怎么设计，源文件里又该怎么设计。

## 一、 什么是头文件
头文件是存放其他源文件链接时需要声明的变量、函数、类。头文件实际上把原本声明在实现文件里的部分剥离出来，形成的一个函数。每个源文件使用include引用它的时候，会直接把头文件里面的代码copy到调用的部分，这会发生在程序预处理的阶段。

```cpp
// preprocessing.h
void add(int a, int b);
// main.cpp
#include "preprocessing.h"
int main() {
}
```

我们对这个简单的程序执行 ：g++ main.cpp -E -o preprocessing 生成预处理后的文件

```cpp
# 0 "main.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "main.cpp"
# 1 "preprocessing.h" 1
void add(int a, int b);
# 2 "main.cpp" 2
int main() {

}
```
这里其实已经可以看出，我们不用编译处理头文件的内容，它直接就插入到main里了。

## 二、为什么需要头文件

#### 1. 没有头文件会发生什么
在不使用头文件的情况下，我们要实现多文件编译就需要多个cpp源文件。c++编译器对于源文件的编译是单独的，每个文件单独生成一个编译单元（在linux下是 .o, windows下是.obj）,然后再对这些编译单元进行链接，生成可执行文件。


我们用一个student类的案例来说明。
```cpp
// student.cpp
class Student {
	
};
// main.cpp
int main() {
    Student student;
}
```
我们分别对两个源文件进行汇编和链接
g++ main.cpp -c -o main.obj 
g++ student.cpp -c  -o  student.obj
g++ main.obj   student.obj  -o student.exe![image-20220427002845362](../../../../typora_picure/image-20220427002845362.png)

很显然失败了，其实对于好一点的编译器来说，你在编写代码时就会有下划线警告
如果没有头文件提前声明，main文件怎么知道student是什么，又怎么知道它的大小。它们是独立编译的。这里其实可以引出另一块内容，关于类的双重依赖问题，下次再讲。

#### 2. 文件形式的统一性
对于linux来说，没有所谓的文件类型，只有文件权限是否可执行。本质对于操作系统来说cpp和h文件都是文件，所以当我们引用cpp源文件的时候，它的效果跟头文件是一样的。后缀只是对用户来说可以很好的识别文件是干嘛的。但是对于windows来说，他有自己的文件解释的方式，但本质没啥区别，就像你可以用txt格式打开一个cpp文件。

既然没有声明，那我们就给他自己搞一个声明。其中一个办法是直接include "student.cpp"
```cpp
#include "student.cpp"
int main() {
    Student student;
}
```
这样就可以解决。 还有一种办法是使用关键字export，但现在大部分编译器不接受这种办法了。

#### 为什么需要头文件
既然可以调用源文件里的实现代码来解决问题，为什么还需要使用头文件呢？有了上面文件统一性的分析，我们可以更准确的提出问题，为什么需要把程序的声明抽离出来呢？

如果一个头文件里存在函数的实现或者全局变量的定义，他只被一个源文件引用的话是可以的，但是他被多个源文件同时引用的话就会出现重定义的错误。如下面这个简单的例子。

```cpp
//head.h
int add(int a, int b) { return a + b; } 
// another.cpp
#include "head.h"
// main.cpp
#include "head.h"
int main() {
    add(10, 20);
}
```
![image-20220427072316210](../../../../typora_picure/image-20220427072316210.png)

上面我故意不提链接的作用，这里有必要说一下了。

#### 链接
顾名思义，链接就是将多个编译单元链接起来生成一个二进制可执行文件。
编译单个cpp源文件的时候，对于别的文件中的函数与全局变量，它是没法知道它们的准确地址的。因此在编译结束后需要链接器将各种还没有准确地址的符号（函数、变量）设置正确的虚拟地址，组装在一起形成一个完整的可执行文件。

但是正如最开始没有头文件声明所讲，虽然几个源文件链接起来了，但是没有函数的声明，调用函数的文件找不到该函数定义的位置，所以需要头文件声明来指明函数声明的位置。
用单文件来举例，这个跟函数可以定义在调用函数的后面，那样的话就必须把声明放在调用函数的前面。（但是现在的编译器已经很智能了，可以帮你解决这种低级错误。）

了解到链接所作的事情，我们就知道了为什么不能把函数实现和全局变量的声明放在头文件里了，当多个文件去引用该文件的时候，编译器不会做任何处理，直接把代码复制到引用头文件的位置就完事了。
但这就难道链接了，对于多个编译单元，他在不同文件看到了一模一样的函数或者对象，他咋知道该怎么分配内存，所以就直接报错了。
这里你在写一个单文件的时候，重复定义一个函数但是没有重载的时候应该也可以看到类似的报错，他们本质是一样的。

这里可能会有人觉得调用#pragma once宏或者#ifndef XXX就万事大吉了，那你搞错这两个宏的作用了。这两个宏的作用主要是防止一个源文件多次包含该头文件，这里我只是不同的源文件包含头文件了，会直接忽视宏的作用。
头文件重复编译往往不是程序员自己写两个头文件，而是因为头文件里的依赖关系。
例如头文件A，B和main源文件。 A 依赖B， 所以在A里先引用了B，但是在main里，我们同时引用了A和B，这就会导致头文件重复引用的问题。

对于只包含声明的头文件来说，重复引用会造成代码扩展，文件大小变大，编译效率变低。
但是没有合理规范头文件的编写，假设在头文件里写了全局变量的定义或者函数的实现，就会导致重定义的问题。

#### 头文件里应该放什么
1. const 全局变量和static全局变量
2. 宏定义，包括保护的宏和判断的宏。
3. inline、static、extern函数的定义
4. typedef声明
5. 外部函数、类成员函数的声明
6. 全局变量的声明
7. 结构体、联合体、枚举的声明
8. 类的定义（里面包括了什么成员变量，类内部是什么结构）
按照自己的需求去设计，除了固定的概式，头文件编写是自由的。这里我没有特别深入，只有大概的概念，这里简单介绍一下。

a. inline函数需要定义在同一个文件，方便编译器的寻找，防止重定义的功能是编译去的完成的。
b. static变量会在每个引用头文件的文件里生成一份，所以他们是不共享的，不会造成重定义的问题。但是它也不能完成所有文件同时使用一份的功能，看自己需要添加。
c. 类的定义，这里的定义不包括成员函数的实现，编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，才知道需要给它分配多少内存的空间。

static 和 const 的代码验证（每个引用的头文件都独立拥有这两个元素）
```cpp
//static

//another.cpp
#include "head.h"
#include <iostream>
void show() {
    std::cout << x << std::endl;
}

//head.h
static int x = 10;
void show();

// main.cpp
#include "head.h"
#include <iostream>
int main() {
    std::cout << x << std::endl;
    x = 20;
    show();
}
```
输出结果是10， 10。说明我在main文件改变的静态变量x并没有影响到another文件里的静态变量x


```cpp
//const

//another.cpp
#include "head.h"
#include <iostream>
void show() {
    printf("%lld\n", &x);
}

//head.h
const int x = 10;
void show();

//main.cpp
#include "head.h"
#include <iostream>
int main() {
    printf("%lld\n", &x);
    show();
}
```

![image-20220427174959463](../../../../typora_picure/image-20220427174959463.png)
这里对同一个const变量打印出来的地址是不同的，所以他们存储的不是同一个常量。

#### 写出一个规范的头文件代码
1. 一个模块通常包含多个.c文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个.h，文件名为目录名。
2. 如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名。
3. 头文件不要使用非习惯用法的扩展名，如.inc， 使用h就好，方便自己也方便他人。
4. 增强头文件的独立性，减少头文件之间的依赖关系。
5. 设置好头文件的宏定义，保护头文件

#### 介绍hpp文件
基于文件形式的统一性，我们应该把文件类型思想抛弃，更应该把这个后缀看成是写文件的一个规范。对于h来说，我里面就写声明，cpp里面我就写实现（一个h文件对应一个或多个cpp文件）。
而hpp则是一个既可以写声明和定义的文件。这个文件直接像头文件一样被其他文件引用，同时不需要单独汇编，直接预处理到源文件里面去。
设计这个文件类型我觉得主要是应和多文件编译的大流，可以把一部分功能剥离出来，减少阅读代码的压力。
由于hpp里面会放实现和定义的部分，所以在hpp文件里需要使用#ifndef XXX或者#pragma once 的宏。同时不要把hpp文件引用到多个cpp文件里去。
hpp主要是为了模板设计的，看到模板的编译过程你应该就明白了。

两种宏的区别可以自行百度。pragma 是新出的，对老版本的编译器不支持，它放在文件开头一次性对整个文件进行保护，所以在编译时不需要打开文件就可以判断是否可以引用该头文件了，这可以提高编译的效率。


## 三、模板在编译阶段会发生什么
相信有了上面的基础，了解这部分不会太难。

模板不是一个类型，它只作为一个工具帮助编译器生成相应的代码（对于函数而言，传入相应的对象类型，生成具体的函数版本）。所以在编译阶段模板不会直接生成二进制文件，而是等待到有代码初始化了模板的对象（准确来说是在对象使用对应的成员函数的时候），编译器使用模板，通过更换模板参数来创建数据类型。这个过程就是模板实例化通过该会发生模板实例化。（对于编译器来说，模板正如其名，就是一个制造指定代码的模具）


对于编译器来说是模板是一个生成代码的东西，有没有觉得很眼熟，没错，宏定义也是这么干的。编译器在预处理的时候，先通过给定的宏进行宏展开，然后再编译相应的代码。但是模板的本质不是宏，宏是发生在预处理的简单替换，而模板则是深入语义方面的。这里只是做一个简单的例子让你好理解模板其实不是一个实际的东西，更像是给编译器的一个代码规范.（查了很多资料也没找到很清楚的描述模板编译器到底干了啥的文章）

而模板的实例化需要编译器找到可用的代码来制造这份代码，这就需要在这个文件为编译器提供模板的声明和定义（所以随便打开一个c++需要模板的头文件，比如vecotr，都能在里面找到函数的实现，但是在c语言里头文件里只有函数的声明。）

##* 重点！！！！！！！！*
不知道你一路看下来是不是又这个疑问，明明我可以用头文件来声明它，这样要调用的时候编译器不就直接找到了吗，为什么还一定要定义在头文件（包括模板和上面说的类的定义）

下面是我搜集大量资料后自己的理解：
这里有关编译的顺序了。（以模板为例）
之前说过模板的本质不是宏定义，它需要对语义进行深度的处理，所以它不是再预处理的时候就完成了模板实例化代码的创建的，其实这一步发生再汇编（也就是生成编译单元那一步）。

而前面所说，编译单元是独立的，即使你有了一个头文件来声明这个类或者模板，但是你本质上是没有这份定义的。你有这份定义也是发生在链接以后，你可以统一多个源文件的地址，从而通过这个地址去调用他。这种对于函数来说是无所谓的，因为你只需要知道使用这个函数的时候要传什么参数，返回什么参数，他不要求对里面实现有什么了解，只是做一个简单的语法检查。

但是对于类和模板来说这种方法就不行了。
对于类来说，在汇编那一步，编译器需要知道他要为这个类型分配多少空间的内存，他不能拖到链接再去做这件事，所以这里他无法解决，就直接报错了。
而对于模板来说，编译器要在编译时为特定的对象生成指定的代码，所以他也必须在汇编阶段知道模板的定义。这就是为什么对于类和模板来说，定义一定要放在头文件里。


**小插曲**：当然模板也可以放在cpp文件，不过只能是模板的特例（给定了具体的类型），模板在特例后会被编译器认作是一份代码，所以可以单独进行编译链接。

目前的编译器会为模板的特例化进行一个规整，讲相同类型的模板特例只保留一个，比如Smart机制，我没深入去了解。

### 一点点感言
其实多文件编程里面还有很多门道，包括上面提到的包含类声明的头文件解决依赖的问题，命名空间的嵌套等等，在大型的项目整合起来，逻辑就会变得十分复杂。
但是总归来说，代码是写给人看的。*尤其是c++，不要执迷于各种花里胡哨的特性，在写代码的时候不要秀花招，用最朴素的方法解决问题往往是最佳的解。*

## 欢迎大神补充！！



参考文档：
我写的差不多的时候看到了这篇菜鸟教程，感觉跟我整理的近似度很高了，但是比我写的更详细，里面包括了我没详细讲的头文件里为什么可以存放这些内容的解释以及头文件保护机制，很值得参考。
https://www.runoob.com/w3cnote/cpp-header.html#:~:text=%E4%B8%80%EF%BC%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%86%99%20const%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%82%20%E5%9B%A0%E4%B8%BA%E5%85%A8%E5%B1%80%E7%9A%84,const%20%E5%AF%B9%E8%B1%A1%E9%BB%98%E8%AE%A4%E6%98%AF%E6%B2%A1%E6%9C%89%20extern%20%E7%9A%84%E5%A3%B0%E6%98%8E%E7%9A%84%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%83%E5%8F%AA%E5%9C%A8%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E6%95%88%E3%80%82

https://zhuanlan.zhihu.com/p/387773355
https://blog.csdn.net/weixin_42018112/article/details/82289971
https://zhuanlan.zhihu.com/p/259733778
https://blog.csdn.net/weixin_42018112/article/details/82357002
https://blog.csdn.net/weixin_46024428/article/details/118543827
https://blog.csdn.net/xulei364132789/article/details/9224965
https://blog.csdn.net/timerzip/article/details/88741829